## HTTP Protocol

> Hypertext Transfer Protocol,超文本传输协议

* 固定客户端和服务器之前的数据传输格式
* 让客户端和服务器能有效的进行数据沟通

![](/source/images/http.png)


HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。

## HTTP的基本性质
* HTTP是简单的
* HTTP是可扩展的
* HTTP是无状态、有会话的
* HTTP和连接

## HTTP报文

**HTTP-Request**
1. 首行是Request-Line包括：请求方法，请求 URI，协议版本，CRLF
2. 首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以 CRLF 结束
3. 请求头和消息实体之间有一个CRLF 分隔
4. 根据实际请求需要可能包含一个消息实体 
> HTTP请求的例子

```javascript
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&age=25
```


**HTTP-Response**

> 状态行

HTTP协议版本、状态码、状态英文标识
eg: HTTP/1.1 200 OK

> 响应头

服务器的描述、返回数据的描述
* Sever: 服务器类型
* Content-Type: 返回数据的类型
* Content-Length: 返回数据的长度
* Date: 响应的时间
![](/images/http/response.png)


> 实体内容

服务器返回给客户端的具体数据
![](/images/http/process.png)

## 状态码

![](/images/http/http-code.png)

* 100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息

* 200  OK 代表一次成功的http请求。
* 201  Created    请求成功并且服务器创建了新的资源
* 202  Accepted   服务器已接受请求，但尚未处理

* 204 No Content 请求已经被服务器成功执行，但是服务器不会返回资源内容，
这个状态码可以这样理解：就是告诉客户端，你的请求我已经处理了，但是我没东西答复你，你也不用改变什么。

* 301 Moved Permanently 表示请求的URL已经永久的改变了。
这是一些服务端在迁移服务器时会经常用到的状态码。如果服务端返回了301状态码，
那么在响应头中往往会包含一个Location响应头，它包含了资源的新地址。通常浏览器遇到这个响应状态码，
会直接跳转到新的地址，有些浏览器会缓存新的地址（Firefox），在下次请求时，不去请求老的服务器，
只去请求新的url。所以，如果你的资源部是不是永久改变的话，那么请慎用这个状态码。

* 302 Found 如果你的资源搬离只是临时的，那么请使用这个状态响应码。在一些企业应用中，
302往往作为一种重定向的手段，比如说将请求转到单点认证服务器。

* 304 Not Modified 这个状态码告诉客户端资源并没有发生改变，可以继续使用缓存副本，
这个状态码可以说让开发人员又爱又恨，为什么这么说呢？因为我们需要这个状态码，
让浏览器可以更多的使用缓存，提高网站性能。但是，我们在修改代码后，
往往又不希望因为缓存问题导致客户使用时出现bug。
所以如何很好的配置服务器缓存策略是一个需要思考的问题。

* 400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求

* 401 Unauthorized 表示客户端访问的资源是受保护的，服务器希望客户端能够带上认证信息后，
再去请求服务器资源。服务器会在响应头中带上WWW-Authenticate，告诉客户端编码方式。

* 403 Forbidden 服务器认为客户端没有访问资源的权限。

* 404 Not Found 资源没有找到，通常是用在请求静态资源时，服务器会返回。
如果服务器报了404错误，服务器端开发人员应该跟踪日志，查找资源找不到的原因。
当然了，还有可能是被代理拦截了，然后强制返回404。

* 500 Internal ServerError：服务端错误，往往出现在动态资源的请求中，出现这个错误的原因很多。
但是出现这个错误，往往是程序编码问题，开发人员应该快速定位问题，尽快解决问题。

* 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）

### 完整版

> 1**(信息类)：表示接收到请求并且继续处理

* 100——客户必须继续发出请求
* 101——客户要求服务器根据请求转换HTTP协议版本

> 2**(响应成功)：表示动作被成功接收、理解和接受

* 200——表明该请求被成功地完成，所请求的资源发送回客户端
* 201——提示知道新文件的URL
* 202——接受和处理、但处理未完成
* 203——返回信息不确定或不完整
* 204——请求收到，但返回信息为空
* 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
* 206——服务器已经完成了部分用户的GET请求

> 3**(重定向类)：为了完成指定的动作，必须接受进一步处理

* 300——请求的资源可在多处得到
* 301——本网页被永久性转移到另一个URL
* 302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
* 303——建议客户访问其他URL或访问方式
* 304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用
* 305——请求的资源必须从服务器指定的地址得到
* 306——前一版本HTTP中使用的代码，现行版本中不再使用
* 307——申明请求的资源临时性删除

> 4**(客户端错误类)：请求包含错误语法或不能正确执行

* 400——客户端请求有语法错误，不能被服务器所理解
* 401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用

  HTTP 401.1 - 未授权：登录失败

  HTTP 401.2 - 未授权：服务器配置问题导致登录失败

  HTTP 401.3 - ACL 禁止访问资源

  HTTP 401.4 - 未授权：授权被筛选器拒绝

  HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
* 402——保留有效ChargeTo头响应
* 403——禁止访问，服务器收到请求，但是拒绝提供服务

  HTTP 403.1 禁止访问：禁止可执行访问

  HTTP 403.2 - 禁止访问：禁止读访问

  HTTP 403.3 - 禁止访问：禁止写访问

  HTTP 403.4 - 禁止访问：要求 SSL

  HTTP 403.5 - 禁止访问：要求 SSL 128

  HTTP 403.6 - 禁止访问：IP 地址被拒绝

  HTTP 403.7 - 禁止访问：要求客户证书

  HTTP 403.8 - 禁止访问：禁止站点访问

  HTTP 403.9 - 禁止访问：连接的用户过多

  HTTP 403.10 - 禁止访问：配置无效

  HTTP 403.11 - 禁止访问：密码更改

  HTTP 403.12 - 禁止访问：映射器拒绝访问

  HTTP 403.13 - 禁止访问：客户证书已被吊销

  HTTP 403.15 - 禁止访问：客户访问许可过多

  HTTP 403.16 - 禁止访问：客户证书不可信或者无效

  HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效

* 404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL
* 405——用户在Request-Line字段定义的方法不允许
* 406——根据用户发送的Accept拖，请求资源不可访问
* 407——类似401，用户必须首先在代理服务器上得到授权
* 408——客户端没有在用户指定的饿时间内完成请求
* 409——对当前资源状态，请求不能完成
* 410——服务器上不再有此资源且无进一步的参考地址
* 411——服务器拒绝用户定义的Content-Length属性请求
* 412——一个或多个请求头字段在当前请求中错误
* 413——请求的资源大于服务器允许的大小
* 414——请求的资源URL长于服务器允许的长度
* 415——请求资源不支持请求项目格式
* 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
* 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。

> 5**(服务端错误类)：服务器不能正确执行一个正确的请求

* HTTP 500 - 服务器遇到错误，无法完成请求

  HTTP 500.100 - 内部服务器错误 - ASP 错误
  HTTP 500-11 服务器关闭

  HTTP 500-12 应用程序重新启动

  HTTP 500-13 - 服务器太忙

  HTTP 500-14 - 应用程序无效

  HTTP 500-15 - 不允许请求 global.asa

* Error 501 - 未实现

* HTTP 502 - 网关错误

* HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常

## HTTP常用请求的方法

| 序号 | 方法 | 描述 |
| :------| :------| :------ |
| 1 | GET | 请求指定的页面信息，并返回实体主体。 |
| 2 | HEAD | 类似GET，但只返回 HTTP 报头，不返回文档主体。 |
| 3 | POST | 向指定资源提交数据进行处理请求。新的资源的建立/已有资源的修改。 |
| 4 | PUT | 从客户端向服务器传送的数据取代指定的文档的内容。（全部取代） |
| 5 | PATCH | 从客户端向服务器传送的数据取代指定的文档的内容。（部分取代） |
| 6 | DELETE | 局部更新资源。 |
| 7 | CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 |
| 8 | OPTIONS | 允许客户端查看服务器的性能，也就是获取客户端能对资源做什么操作的信息。 |
| 9 | TRACE | 回显服务器收到的请求，主要用于测试或诊断。 |
> GET /tickets # 获取ticket列表

> GET /tickets/12 # 查看某个具体的ticket

> POST /tickets # 新建一个ticket

> PUT /tickets/12 # 更新ticket 12

> PATCH /tickets/12 # 更新ticket 12

> DELETE /tickets/12 # 删除ticekt 12

## HTTP能控制什么
> 以下是可以被HTTP控制的常见特性

* 缓存

    文档如何缓存能通过HTTP来控制。服务端能告诉代理和服务端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。

* 开放同源限制

    为了防止网络窥听和其他隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自与`相同来源`的网页才能够获取网站的全部信息。这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）。

* 认证

    一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用`Authenticate`相似的头部即可，或用HTTP Cookies来设置制定的会话。

* 代理和隧道

    通常情况下，服务器和／或客户端是处于内网的，对外网隐藏真实IP地址。因此HTTP请求就要通过代理越过这个网络屏障。但并非所有的代理都是HTTP代理。例如，SOCKS协议的代理就运作在更底层，一些像FTP这样的协议也能够被它们处理。

* 会话

    使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。

## 一个页面从输入 URL 到页面加载显示完成的过程

   1. 浏览器根据请求的URL交给DNS域名解析，找到真实IP
   2. 发起TCP的3次握手,建立TCP连接后发起http请求
   3. 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）
   4. 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）
   5. 载入解析到的资源文件，渲染页面，完成。



[creating-crud-app-minutes-angulars-resource](https://www.sitepoint.com/creating-crud-app-minutes-angulars-resource/)
